using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using EVServiceCenter.Core.Domains.Invoices.Interfaces;
using EVServiceCenter.Core.Domains.Payments.Constants;
using EVServiceCenter.Core.Domains.Payments.DTOs.Requests;
using EVServiceCenter.Core.Domains.Payments.DTOs.Responses;
using EVServiceCenter.Core.Domains.Payments.Interfaces;
using EVServiceCenter.Core.Entities;
using EVServiceCenter.Core.Enums;
using EVServiceCenter.Infrastructure.Helpers;
using EVServiceCenter.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace EVServiceCenter.Infrastructure.Domains.Payments.Services;

/// <summary>
/// Payment orchestration service - coordinates payment lifecycle
/// Business logic layer: validates, orchestrates gateways, and updates invoice
/// </summary>
public class PaymentService : IPaymentService
{
    private readonly EVDbContext _context;
    private readonly IVNPayService _vnPayService;
    private readonly IMoMoService _moMoService;
    private readonly IInvoiceService _invoiceService;
    private readonly IConfiguration _configuration;
    private readonly ILogger<PaymentService> _logger;

    public PaymentService(
        EVDbContext context,
        IVNPayService vnPayService,
        IMoMoService moMoService,
        IInvoiceService invoiceService,
        IConfiguration configuration,
        ILogger<PaymentService> logger)
    {
        _context = context;
        _vnPayService = vnPayService;
        _moMoService = moMoService;
        _invoiceService = invoiceService;
        _configuration = configuration;
        _logger = logger;
    }

    /// <summary>
    /// Create payment: Gateway redirect or manual recording
    /// </summary>
    public async Task<PaymentGatewayResponseDto> CreatePaymentAsync(
        CreatePaymentRequestDto request,
        int createdBy,
        string ipAddress,
        CancellationToken cancellationToken = default)
    {
        // Validate invoice and amount
        var invoice = await ValidateInvoiceForPayment(request.InvoiceId, request.Amount, cancellationToken);

        // Get payment method
        var paymentMethod = await GetPaymentMethodByType(request.PaymentMethod, cancellationToken);

        // Create Payment entity (status = Pending for gateway, Completed for manual)
        var payment = await CreatePaymentEntity(
            invoice,
            paymentMethod,
            request.Amount,
            createdBy,
            cancellationToken);

        // Route to appropriate handler
        return request.PaymentMethod switch
        {
            PaymentMethodType.VNPay => await CreateVNPayPayment(payment, request, ipAddress, cancellationToken),
            PaymentMethodType.MoMo => await CreateMoMoPayment(payment, request, cancellationToken),
            PaymentMethodType.Cash or PaymentMethodType.BankTransfer =>
                await RecordManualPaymentInternal(payment, request, cancellationToken),
            _ => throw new InvalidOperationException($"Payment method {request.PaymentMethod} not supported")
        };
    }

    /// <summary>
    /// Process VNPay callback (IPN/Return URL)
    /// Uses database transaction with serializable isolation to prevent race conditions
    /// </summary>
    public async Task<PaymentCallbackResult> ProcessVNPayCallbackAsync(
    VNPayCallbackDto callback,
    CancellationToken cancellationToken = default)
    {
        // ‚úÖ FIX: Use ExecutionStrategy to support retry + manual transactions
        var strategy = _context.Database.CreateExecutionStrategy();

        return await strategy.ExecuteAsync(async () =>
        {
            await using var transaction = await _context.Database.BeginTransactionAsync(
                System.Data.IsolationLevel.Serializable,
                cancellationToken);

            try
            {
                if (!_vnPayService.VerifyCallbackAndExtractPaymentCode(callback, out var paymentReference))
                {
                    _logger.LogWarning("VNPay callback signature verification failed for reference {PaymentReference}", callback.vnp_TxnRef);
                    return new PaymentCallbackResult(PaymentCallbackStatus.InvalidSignature, "Invalid signature");
                }

                if (string.IsNullOrWhiteSpace(paymentReference))
                {
                    _logger.LogWarning("VNPay callback did not include a transaction reference");
                    await transaction.RollbackAsync(cancellationToken);
                    return new PaymentCallbackResult(PaymentCallbackStatus.PaymentNotFound, "Missing transaction reference");
                }

                if (!int.TryParse(paymentReference, out var paymentId))
                {
                    _logger.LogWarning(
                        "VNPay callback reference {PaymentReference} is not a valid PaymentId",
                        paymentReference);
                    await transaction.RollbackAsync(cancellationToken);
                    return new PaymentCallbackResult(PaymentCallbackStatus.PaymentNotFound, "Invalid payment reference");
                }

                var payment = await _context.Set<Payment>()
                    .Include(p => p.Invoice)
                    .FirstOrDefaultAsync(p => p.PaymentId == paymentId, cancellationToken);

                if (payment == null)
                {
                    _logger.LogWarning(
                        "Payment not found for VNPay PaymentId {PaymentId}",
                        paymentId);
                    await transaction.RollbackAsync(cancellationToken);
                    return new PaymentCallbackResult(PaymentCallbackStatus.PaymentNotFound, "Order not found");
                }

                _logger.LogInformation(
                    "Processing VNPay callback for Payment {PaymentId} ({PaymentCode})",
                    payment.PaymentId, payment.PaymentCode);

                if (payment.Status == PaymentStatus.Completed)
                {
                    _logger.LogInformation("Payment {PaymentCode} already completed, skipping duplicate callback", payment.PaymentCode);
                    await transaction.CommitAsync(cancellationToken);
                    return new PaymentCallbackResult(PaymentCallbackStatus.AlreadyProcessed, "Payment already processed.");
                }

                if (payment.Status == PaymentStatus.Processing)
                {
                    _logger.LogWarning("Payment {PaymentCode} is being processed by another callback, skipping", payment.PaymentCode);
                    await transaction.RollbackAsync(cancellationToken);
                    return new PaymentCallbackResult(PaymentCallbackStatus.AlreadyProcessed, "Payment is processing");
                }

                payment.Status = PaymentStatus.Processing;
                await _context.SaveChangesAsync(cancellationToken);

                PaymentCallbackStatus status;
                string? statusMessage = null;

                if (callback.IsSuccess)
                {
                    var callbackAmount = callback.GetAmount();
                    var expectedAmount = payment.Amount;

                    if (Math.Abs(callbackAmount - expectedAmount) > 1m)
                    {
                        var message = $"Amount mismatch. Expected {expectedAmount:N0}, received {callbackAmount:N0}";
                        _logger.LogWarning(
                            "Amount mismatch for payment {PaymentCode}. Expected {Expected}, received {Received}",
                            payment.PaymentCode, expectedAmount, callbackAmount);

                        await FailPayment(
                            payment,
                            "01",
                            "Invalid amount",
                            cancellationToken);

                        status = PaymentCallbackStatus.InvalidAmount;
                        statusMessage = message;
                    }
                    else
                    {
                        await CompletePayment(
                            payment,
                            callbackAmount,
                            callback.vnp_TransactionNo,
                            callback.vnp_ResponseCode,
                            _vnPayService.GetResponseMessage(callback.vnp_ResponseCode),
                            callback.GetPaymentDate(),
                            cancellationToken);

                        status = PaymentCallbackStatus.Success;
                    }
                }
                else
                {
                    await FailPayment(
                        payment,
                        callback.vnp_ResponseCode,
                        _vnPayService.GetResponseMessage(callback.vnp_ResponseCode),
                        cancellationToken);

                    status = PaymentCallbackStatus.Failed;
                    statusMessage = $"Gateway reported failure (Code: {callback.vnp_ResponseCode})";
                }

                await _context.SaveChangesAsync(cancellationToken);
                await transaction.CommitAsync(cancellationToken);

                return new PaymentCallbackResult(status, statusMessage);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing VNPay callback");
                await transaction.RollbackAsync(cancellationToken);
                return new PaymentCallbackResult(PaymentCallbackStatus.Error, ex.Message);
            }
        });
    }


    /// <summary>
    /// Process MoMo callback (IPN/Return URL)
    /// Uses database transaction with serializable isolation to prevent race conditions
    /// </summary>
    public async Task<bool> ProcessMoMoCallbackAsync(
        MoMoCallbackDto callback,
        CancellationToken cancellationToken = default)
    {
        // Start transaction to prevent concurrent callback processing
        await using var transaction = await _context.Database.BeginTransactionAsync(
            System.Data.IsolationLevel.Serializable,
            cancellationToken);

        try
        {
            // Verify signature
            if (!_moMoService.VerifyCallbackAndExtractPaymentCode(callback, out var paymentCode))
            {
                _logger.LogWarning("MoMo callback signature verification failed for {PaymentCode}", paymentCode);
                return false;
            }

            // Find payment by code (with transaction lock)
            var payment = await _context.Set<Payment>()
                .Include(p => p.Invoice)
                .FirstOrDefaultAsync(p => p.PaymentCode == paymentCode, cancellationToken);

            if (payment == null)
            {
                _logger.LogWarning("Payment {PaymentCode} not found for MoMo callback", paymentCode);
                await transaction.RollbackAsync(cancellationToken);
                return false;
            }

            // Check if already processed (idempotency)
            if (payment.Status == PaymentStatus.Completed)
            {
                _logger.LogInformation("Payment {PaymentCode} already completed, skipping duplicate callback", paymentCode);
                await transaction.CommitAsync(cancellationToken);
                return true;
            }

            // Check if currently being processed by another request
            if (payment.Status == PaymentStatus.Processing)
            {
                _logger.LogWarning("Payment {PaymentCode} is being processed by another callback, skipping", paymentCode);
                await transaction.RollbackAsync(cancellationToken);
                return true;
            }

            // Mark as processing to prevent concurrent handlers
            payment.Status = PaymentStatus.Processing;
            await _context.SaveChangesAsync(cancellationToken);

            // Update payment status based on callback
            if (callback.IsSuccess)
            {
                await CompletePayment(
                    payment,
                    callback.amount,
                    callback.transId,
                    callback.ResponseCode,
                    _moMoService.GetResponseMessage(callback.resultCode),
                    callback.GetPaymentDate(),
                    cancellationToken);
            }
            else
            {
                await FailPayment(
                    payment,
                    callback.ResponseCode,
                    _moMoService.GetResponseMessage(callback.resultCode),
                    cancellationToken);
            }

            // Save all changes (Payment, OnlinePayment, Invoice) in single transaction
            await _context.SaveChangesAsync(cancellationToken);

            // Commit transaction
            await transaction.CommitAsync(cancellationToken);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing MoMo callback");
            await transaction.RollbackAsync(cancellationToken);
            return false;
        }
    }

    /// <summary>
    /// Record manual payment (Cash, BankTransfer)
    /// </summary>
    public async Task<PaymentResponseDto> RecordManualPaymentAsync(
        CreatePaymentRequestDto request,
        int createdBy,
        CancellationToken cancellationToken = default)
    {
        // Validate invoice and amount
        var invoice = await ValidateInvoiceForPayment(request.InvoiceId, request.Amount, cancellationToken);

        // Get payment method
        var paymentMethod = await GetPaymentMethodByType(request.PaymentMethod, cancellationToken);

        // Create and complete payment immediately
        var payment = await CreatePaymentEntity(
            invoice,
            paymentMethod,
            request.Amount,
            createdBy,
            cancellationToken);

        // Mark as completed immediately for manual payments
        payment.Status = PaymentStatus.Completed;
        payment.PaymentDate = DateTime.UtcNow;
        payment.TransactionRef = request.TransactionRef;
        payment.Notes = request.Notes;

        await _context.SaveChangesAsync(cancellationToken);

        // Update invoice (manual payment has no gateway transaction ID)
        await UpdateInvoiceAfterPayment(payment, request.TransactionRef ?? payment.PaymentCode, cancellationToken);

        _logger.LogInformation("Manual payment {PaymentCode} recorded successfully", payment.PaymentCode);

        return MapToResponseDto(payment);
    }

    /// <summary>
    /// Get payment by ID
    /// </summary>
    public async Task<PaymentResponseDto?> GetPaymentByIdAsync(
        int paymentId,
        CancellationToken cancellationToken = default)
    {
        var payment = await _context.Set<Payment>()
            .AsNoTracking()
            .Include(p => p.Invoice)
            .Include(p => p.Method)
            .Include(p => p.OnlinePayments)
            .FirstOrDefaultAsync(p => p.PaymentId == paymentId, cancellationToken);

        return payment == null ? null : MapToResponseDto(payment);
    }

    /// <summary>
    /// Get payment by code
    /// </summary>
    public async Task<PaymentResponseDto?> GetPaymentByCodeAsync(
        string paymentCode,
        CancellationToken cancellationToken = default)
    {
        var payment = await _context.Set<Payment>()
            .AsNoTracking()
            .Include(p => p.Invoice)
            .Include(p => p.Method)
            .Include(p => p.OnlinePayments)
            .FirstOrDefaultAsync(p => p.PaymentCode == paymentCode, cancellationToken);

        return payment == null ? null : MapToResponseDto(payment);
    }

    /// <summary>
    /// Get all payments for an invoice
    /// </summary>
    public async Task<List<PaymentResponseDto>> GetPaymentsByInvoiceIdAsync(
        int invoiceId,
        CancellationToken cancellationToken = default)
    {
        var payments = await _context.Set<Payment>()
            .AsNoTracking()
            .Include(p => p.Invoice)
            .Include(p => p.Method)
            .Include(p => p.OnlinePayments)
            .Where(p => p.InvoiceId == invoiceId)
            .OrderByDescending(p => p.PaymentDate)
            .ToListAsync(cancellationToken);

        return payments.Select(MapToResponseDto).ToList();
    }

    #region Private Helper Methods - Validation

    /// <summary>
    /// Validate invoice exists and amount doesn't exceed outstanding
    /// </summary>
    private async Task<Core.Entities.Invoice> ValidateInvoiceForPayment(
        int invoiceId,
        decimal amount,
        CancellationToken cancellationToken)
    {
        var invoice = await _context.Set<Core.Entities.Invoice>()
            .FirstOrDefaultAsync(i => i.InvoiceId == invoiceId, cancellationToken);

        if (invoice == null)
            throw new KeyNotFoundException($"Invoice {invoiceId} not found");

        if (invoice.OutstandingAmount == null || invoice.OutstandingAmount <= 0)
            throw new InvalidOperationException("Invoice has no outstanding amount");

        if (amount > invoice.OutstandingAmount)
            throw new InvalidOperationException(
                $"Payment amount {amount:N0} exceeds outstanding amount {invoice.OutstandingAmount:N0}");

        return invoice;
    }

    /// <summary>
    /// Get payment method by type string
    /// </summary>
    private async Task<PaymentMethod> GetPaymentMethodByType(
        string methodType,
        CancellationToken cancellationToken)
    {
        var normalized = methodType?.Trim();
        if (string.IsNullOrWhiteSpace(normalized))
            throw new KeyNotFoundException("Payment method not specified");

        var upper = normalized.ToUpperInvariant();

        var methods = await _context.Set<PaymentMethod>()
            .AsNoTracking()
            .ToListAsync(cancellationToken);

        var method = methods.FirstOrDefault(m =>
            string.Equals(m.MethodCode, upper, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(m.GatewayProvider, normalized, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(m.GatewayProvider, upper, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(m.MethodName, normalized, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(m.MethodName, $"{normalized} Gateway", StringComparison.OrdinalIgnoreCase) ||
            m.MethodName?.StartsWith(normalized, StringComparison.OrdinalIgnoreCase) == true);

        if (method == null)
        {
            var available = string.Join(", ", methods.Select(m => $"{m.MethodCode} ({m.MethodName})"));
            throw new KeyNotFoundException($"Payment method '{methodType}' not found. Available: {available}");
        }

        return method;
    }
    #endregion

    #region Private Helper Methods - Payment Creation

    /// <summary>
    /// Create Payment entity (common for all payment types)
    /// </summary>
    private async Task<Payment> CreatePaymentEntity(
        Core.Entities.Invoice invoice,
        PaymentMethod paymentMethod,
        decimal amount,
        int createdBy,
        CancellationToken cancellationToken)
    {
        var payment = new Payment
        {
            PaymentCode = GeneratePaymentCode(),
            InvoiceId = invoice.InvoiceId,
            MethodId = paymentMethod.MethodId,
            Amount = amount,
            Status = PaymentStatus.Pending,
            PaymentDate = DateTime.UtcNow,
            ProcessedBy = createdBy,
            CreatedDate = DateTime.UtcNow
        };

        _context.Set<Payment>().Add(payment);
        await _context.SaveChangesAsync(cancellationToken);

        // Load navigation properties
        payment.Invoice = invoice;
        payment.Method = paymentMethod;

        return payment;
    }

    /// <summary>
    /// Generate unique payment code
    /// </summary>
    private static string GeneratePaymentCode()
    {
        return $"PAY-{DateTime.UtcNow:yyyyMMdd}-{Guid.NewGuid().ToString()[..8].ToUpper()}";
    }

    #endregion

    #region Private Helper Methods - Gateway Handlers

    /// <summary>
    /// Create VNPay payment and get redirect URL
    /// </summary>
    private Task<PaymentGatewayResponseDto> CreateVNPayPayment(
        Payment payment,
        CreatePaymentRequestDto request,
        string ipAddress,
        CancellationToken cancellationToken)
    {
        var vnPayReturnUrl = BuildVNPayReturnUrl(request.ReturnUrl);
        var vnPayIpnUrl = _configuration["VNPay:IpnUrl"];
        vnPayIpnUrl = null; // ?? DISABLED: VNPay IPN test timeout > 6 mins

        // ‚úÖ FIX: Clean OrderInfo - Remove spaces and special characters
        // VNPay requires: "Ti·∫øng Vi·ªát kh√¥ng d·∫•u v√† kh√¥ng bao g·ªìm c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát"
        var cleanOrderInfo = $"Thanhtoan_{payment.Invoice!.InvoiceCode}";

        // ‚ö†Ô∏è TEMPORARY FIX: Disable IPN URL for testing
        // VNPay requires IPN URL to be registered in their system first
        // vnPayIpnUrl = null; // Temporarily disable IPN

        // ‚úÖ IPN ENABLED: Now testing with production-like flow   

        // ‚úÖ FIX: Log all parameters before sending to VNPay
        // _logger.LogInformation(
        //     "üîç VNPay Payment Creation Debug:\n" +
        //     "PaymentId: {PaymentId}\n" +
        //     "PaymentCode: {PaymentCode}\n" +
        //     "Amount: {Amount} VND\n" +
        //     "Invoice: {InvoiceCode}\n" +     
        //     "OrderInfo (Original): Thanh toan hoa don {InvoiceCode}\n" +
        //     "OrderInfo (Cleaned): {CleanOrderInfo}\n" +
        //     "ReturnUrl (Requested): {RequestedUrl}\n" +
        //     "ReturnUrl (Actual): {ActualUrl}\n" +
        //     "IpnUrl: {IpnUrl} (DISABLED FOR TESTING)\n" +
        //     "IP Address: {IpAddress}",
        //     payment.PaymentId,
        //     payment.PaymentCode,
        //     payment.Amount,
        //     payment.Invoice!.InvoiceCode,
        //     cleanOrderInfo,
        //     request.ReturnUrl,
        //     vnPayReturnUrl,
        //     "DISABLED - Need to register with VNPay first",
        //     ipAddress);

        _logger.LogInformation(
            "üîç VNPay Payment Creation Debug:\n" +
            "PaymentId: {PaymentId}\n" +
            "PaymentCode: {PaymentCode}\n" +
            "Amount: {Amount} VND\n" +
            "Invoice: {InvoiceCode}\n" +
            "OrderInfo: {CleanOrderInfo}\n" +
            "ReturnUrl: {ReturnUrl}\n" +
            "IpnUrl: {IpnUrl} ‚úÖ ENABLED\n" +
            "IP Address: {IpAddress}",
            payment.PaymentId,
            payment.PaymentCode,
            payment.Amount,
            payment.Invoice!.InvoiceCode,
            cleanOrderInfo,
            vnPayReturnUrl,
            vnPayIpnUrl,
            ipAddress);

        var vnpayRequest = new VNPayPaymentRequestDto
        {
            PaymentId = payment.PaymentId,
            PaymentCode = payment.PaymentCode,
            Amount = payment.Amount,
            OrderInfo = cleanOrderInfo, // ‚úÖ Use cleaned OrderInfo without spaces
            ReturnUrl = vnPayReturnUrl,
            IpnUrl = vnPayIpnUrl, // NULL - will not include vnp_IpnUrl parameter
            IpAddress = ipAddress,
            CustomerName = request.CustomerName,
            CustomerEmail = request.CustomerEmail,
            CustomerPhone = request.CustomerPhone
        };

        var paymentUrl = _vnPayService.CreatePaymentUrl(vnpayRequest);

        _logger.LogInformation(
            "‚úÖ VNPay Payment URL Generated:\n" +
            "URL Length: {UrlLength}\n" +
            "First 200 chars: {UrlPreview}...",
            paymentUrl.Length,
            paymentUrl.Length > 200 ? paymentUrl.Substring(0, 200) : paymentUrl);

        return Task.FromResult(new PaymentGatewayResponseDto
        {
            PaymentId = payment.PaymentId,
            PaymentCode = payment.PaymentCode,
            Gateway = "VNPay",
            PaymentUrl = paymentUrl,
            ExpiryTime = DateTime.UtcNow.AddMinutes(15)
        });
    }

    /// <summary>
    /// Create MoMo payment and get redirect URL/QR code
    /// </summary>
    private async Task<PaymentGatewayResponseDto> CreateMoMoPayment(
        Payment payment,
        CreatePaymentRequestDto request,
        CancellationToken cancellationToken)
    {
        // Get configured IPN URL from appsettings
        var ipnUrl = _configuration["MoMo:IpnUrl"];
        if (string.IsNullOrEmpty(ipnUrl))
        {
            throw new InvalidOperationException("MoMo IPN URL is not configured in appsettings.json");
        }

        var momoRequest = new MoMoPaymentRequestDto
        {
            PaymentId = payment.PaymentId,
            PaymentCode = payment.PaymentCode,
            Amount = (long)payment.Amount,
            OrderInfo = $"Thanh toan hoa don {payment.Invoice!.InvoiceCode}",
            ReturnUrl = request.ReturnUrl!,
            IpnUrl = ipnUrl
        };

        var response = await _moMoService.CreatePaymentAsync(momoRequest, cancellationToken);

        _logger.LogInformation("MoMo payment created for {PaymentCode}", payment.PaymentCode);

        return response;
    }

    private string BuildVNPayReturnUrl(string? requestedFrontendReturn)
    {
        var baseReturnUrl = _configuration["VNPay:ReturnUrl"];
        if (string.IsNullOrWhiteSpace(baseReturnUrl))
        {
            throw new InvalidOperationException("VNPay Return URL is not configured in appsettings.json");
        }

        // FIX: VNPay KH√îNG CH·∫§P NH·∫¨N query parameters trong returnUrl
        // Ch·ªâ tr·∫£ v·ªÅ base return URL, kh√¥ng th√™m redirect parameter
        // Frontend redirect s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong VNPayReturn endpoint
        _logger.LogInformation(
            "VNPay ReturnUrl configured: {ReturnUrl} (frontend redirect will be handled by controller)",
            baseReturnUrl);

        return baseReturnUrl; // Ch·ªâ return base URL, KH√îNG th√™m query params
    }

    private string? ResolveFrontendRedirectUrl(string? requestedUrl)
    {
        var fallback = _configuration["PaymentGateway:FrontendReturnUrl"];
        if (string.IsNullOrWhiteSpace(fallback))
        {
            var website = _configuration["AppSettings:WebsiteUrl"];
            if (!string.IsNullOrWhiteSpace(website))
            {
                fallback = $"{website.TrimEnd('/')}/payment/result";
            }
        }

        if (string.IsNullOrWhiteSpace(requestedUrl))
        {
            return fallback;
        }

        if (IsUrlInAllowList(requestedUrl))
        {
            return requestedUrl;
        }

        if (!string.IsNullOrWhiteSpace(fallback))
        {
            _logger.LogWarning(
                "Requested return URL {ReturnUrl} is not in the VNPay allow list. Falling back to {Fallback}.",
                requestedUrl,
                fallback);
        }

        return fallback;
    }

    private static string BuildUrlWithQuery(string baseUrl, IDictionary<string, string?> queryParameters)
    {
        if (string.IsNullOrWhiteSpace(baseUrl) || queryParameters == null)
        {
            return baseUrl;
        }

        var encodedParameters = queryParameters
            .Where(kv => !string.IsNullOrWhiteSpace(kv.Key))
            .Select(kv => string.Join("=", Uri.EscapeDataString(kv.Key), Uri.EscapeDataString(kv.Value ?? string.Empty)))
            .ToList();

        if (encodedParameters.Count == 0)
        {
            return baseUrl;
        }

        var separator = baseUrl.Contains('?') ? '&' : '?';
        return baseUrl + separator + string.Join("&", encodedParameters);
    }
    private bool IsUrlInAllowList(string url)
    {
        if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))
        {
            return false;
        }

        var candidate = NormalizeAllowedUrl(uri);
        var allowedUrls = _configuration.GetSection("VNPay:AllowedReturnUrls").Get<string[]>() ?? Array.Empty<string>();

        foreach (var allowed in allowedUrls)
        {
            var normalizedAllowed = NormalizeAllowedUrl(allowed);
            if (!string.IsNullOrEmpty(normalizedAllowed) &&
                string.Equals(candidate, normalizedAllowed, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
        }

        return false;
    }

    private static string NormalizeAllowedUrl(string url)
    {
        return Uri.TryCreate(url, UriKind.Absolute, out var uri)
            ? NormalizeAllowedUrl(uri)
            : url.TrimEnd('/');
    }

    private static string NormalizeAllowedUrl(Uri uri)
    {
        return $"{uri.Scheme}://{uri.Host}{uri.AbsolutePath}".TrimEnd('/');
    }

    /// <summary>
    /// Record manual payment and return gateway response (for consistency)
    /// </summary>
    private async Task<PaymentGatewayResponseDto> RecordManualPaymentInternal(
        Payment payment,
        CreatePaymentRequestDto request,
        CancellationToken cancellationToken)
    {
        // Mark as completed immediately for manual payments
        payment.Status = PaymentStatus.Completed;
        payment.PaymentDate = DateTime.UtcNow;
        payment.TransactionRef = request.TransactionRef;
        payment.Notes = request.Notes;

        await _context.SaveChangesAsync(cancellationToken);

        // Update invoice (manual payment has no gateway transaction ID)
        await UpdateInvoiceAfterPayment(payment, request.TransactionRef ?? payment.PaymentCode, cancellationToken);

        await _context.SaveChangesAsync(cancellationToken);

        return new PaymentGatewayResponseDto
        {
            PaymentId = payment.PaymentId,
            PaymentCode = payment.PaymentCode,
            Gateway = request.PaymentMethod,
            PaymentUrl = string.Empty // No redirect for manual payment
        };
    }

    #endregion

    #region Private Helper Methods - Payment Completion

    /// <summary>
    /// Complete payment after successful gateway callback
    /// NOTE: Does NOT call SaveChangesAsync - caller must commit transaction
    /// </summary>
    private async Task CompletePayment(
        Payment payment,
        decimal paidAmount,
        string gatewayTransactionId,
        string responseCode,
        string responseMessage,
        DateTime? paymentDate,
        CancellationToken cancellationToken)
    {
        // Update Payment status
        payment.Status = PaymentStatus.Completed;
        payment.PaymentDate = paymentDate ?? DateTime.UtcNow;

        // Create OnlinePayment record for gateway details
        var onlinePayment = new OnlinePayment
        {
            PaymentId = payment.PaymentId,
            GatewayTransactionId = gatewayTransactionId,
            GatewayName = payment.Method?.MethodName ?? "Unknown",
            PaymentStatus = PaymentStatus.Completed,
            ResponseCode = responseCode,
            ResponseMessage = responseMessage,
            CreatedDate = DateTime.UtcNow,
            UpdatedDate = DateTime.UtcNow
        };

        _context.Set<OnlinePayment>().Add(onlinePayment);

        // Verify amount matches
        if (Math.Abs(paidAmount - payment.Amount) > 0.01m)
        {
            _logger.LogWarning(
                "Payment amount mismatch for {PaymentCode}. Expected: {Expected}, Received: {Received}",
                payment.PaymentCode, payment.Amount, paidAmount);
        }

        // Update invoice (this uses IInvoiceService which operates on same DbContext)
        await UpdateInvoiceAfterPayment(payment, gatewayTransactionId, cancellationToken);
        await UpdatePaymentIntentAfterGatewayAsync(
            payment,
            paidAmount,
            PaymentIntentStatusEnum.Completed.ToString(),
            gatewayTransactionId,
            cancellationToken);

        _logger.LogInformation("Payment {PaymentCode} completed successfully", payment.PaymentCode);
    }

    /// <summary>
    /// Mark payment as failed
    /// NOTE: Does NOT call SaveChangesAsync - caller must commit transaction
    /// </summary>
    private async Task FailPayment(
        Payment payment,
        string responseCode,
        string responseMessage,
        CancellationToken cancellationToken)
    {
        // Update Payment status
        payment.Status = PaymentStatus.Failed;
        payment.FailureReason = responseMessage;

        // Create OnlinePayment record for failure tracking
        var onlinePayment = new OnlinePayment
        {
            PaymentId = payment.PaymentId,
            GatewayTransactionId = $"FAILED-{payment.PaymentCode}",
            GatewayName = payment.Method?.MethodName ?? "Unknown",
            PaymentStatus = PaymentStatus.Failed,
            ResponseCode = responseCode,
            ResponseMessage = responseMessage,
            CreatedDate = DateTime.UtcNow,
            UpdatedDate = DateTime.UtcNow
        };

        _context.Set<OnlinePayment>().Add(onlinePayment);

        await UpdatePaymentIntentAfterGatewayAsync(
            payment,
            0,
            PaymentIntentStatusEnum.Failed.ToString(),
            null,
            cancellationToken);

        _logger.LogWarning("Payment {PaymentCode} failed. Code: {Code}, Message: {Message}",
            payment.PaymentCode, responseCode, responseMessage);
    }
    /// <summary>
    /// Update invoice after payment completion
    /// Uses IInvoiceService to maintain business logic in one place
    /// </summary>
    private async Task UpdateInvoiceAfterPayment(
        Payment payment,
        string gatewayTransactionId,
        CancellationToken cancellationToken)
    {
        // Use InvoiceService to record payment (maintains business logic in one place)
        // InvoiceService operates on the same DbContext, so changes will be part of the same transaction
        await _invoiceService.RecordPaymentAsync(
            payment.InvoiceId,
            payment.Amount,
            payment.MethodId,
            gatewayTransactionId,
            cancellationToken);

        // ‚úÖ GAP 2 FIX: Synchronize payment status to Appointment
        try
        {
            // Load Invoice with WorkOrder and Appointment relationships
            var invoice = await _context.Set<Invoice>()
                .Include(i => i.WorkOrder)
                    .ThenInclude(w => w!.Appointment)
                .FirstOrDefaultAsync(i => i.InvoiceId == payment.InvoiceId, cancellationToken);

            // Chu·∫©n h√≥a sai l·ªách l√†m tr√≤n: n·∫øu c√≤n < 1ƒë xem nh∆∞ ƒë√£ thanh to√°n ƒë·ªß
            if (invoice?.OutstandingAmount is > 0m and < 1m)
            {
                invoice.OutstandingAmount = 0;
                invoice.PaidAmount = invoice.GrandTotal ?? invoice.PaidAmount;
                invoice.Status = "Paid";
                _logger.LogInformation(
                    "Normalized tiny outstanding for Invoice {InvoiceCode}: set Outstanding=0 to mark Paid",
                    invoice.InvoiceCode);
                await _context.SaveChangesAsync(cancellationToken);
            }

            var appointment = invoice?.WorkOrder?.Appointment;

            if (appointment == null && invoice != null &&
                TryExtractAppointmentIdFromInvoiceNotes(invoice.Notes, out var fallbackAppointmentId))
            {
                appointment = await _context.Appointments
                    .FirstOrDefaultAsync(a => a.AppointmentId == fallbackAppointmentId, cancellationToken);

                if (appointment != null)
                {
                    _logger.LogInformation(
                        "Linked Invoice {InvoiceCode} to Appointment {AppointmentId} via invoice note fallback",
                        invoice.InvoiceCode,
                        appointment.AppointmentId);
                }
            }

            if (appointment != null)
            {
                var paidAmount = invoice?.PaidAmount ?? 0m;
                var outstanding = invoice?.OutstandingAmount ?? 0m;

                var targetStatus = outstanding <= 0
                    ? PaymentStatusEnum.Completed.ToString()
                    : paidAmount > 0
                        ? PaymentStatusEnum.Pending.ToString()
                        : appointment.PaymentStatus ?? PaymentStatusEnum.Pending.ToString();

                appointment.PaidAmount = paidAmount;

                if (!string.Equals(appointment.PaymentStatus, targetStatus, StringComparison.OrdinalIgnoreCase))
                {
                    var previousStatus = appointment.PaymentStatus;
                    appointment.PaymentStatus = targetStatus;
                    appointment.UpdatedDate = DateTime.UtcNow;

                    _logger.LogInformation(
                        "Synchronized payment status for Appointment {AppointmentId} from Invoice {InvoiceCode}. {PreviousStatus} -> {NewStatus} (Paid={PaidAmount:N0}, Outstanding={Outstanding:N0})",
                        appointment.AppointmentId,
                        invoice?.InvoiceCode,
                        previousStatus,
                        targetStatus,
                        paidAmount,
                        outstanding);
                }
                else
                {
                    _logger.LogDebug(
                        "Appointment {AppointmentId} already in payment status {Status} (Paid={PaidAmount:N0}, Outstanding={Outstanding:N0}), skipping sync",
                        appointment.AppointmentId,
                        targetStatus,
                        paidAmount,
                        outstanding);
                }
            }
            else
            {
                _logger.LogInformation(
                    "No Appointment found for Invoice {InvoiceId}, skipping payment status sync",
                    payment.InvoiceId);
            }

            if (invoice != null)
            {
                var subscription = await _context.CustomerPackageSubscriptions
                    .FirstOrDefaultAsync(s => s.InvoiceId == invoice.InvoiceId, cancellationToken);

                if (subscription != null)
                {
                    var previousStatus = subscription.Status;
                    if (!string.Equals(previousStatus, SubscriptionStatusEnum.Active.ToString(), StringComparison.OrdinalIgnoreCase))
                    {
                        subscription.Status = SubscriptionStatusEnum.Active.ToString();
                        subscription.PurchaseDate ??= DateTime.UtcNow;

                        _logger.LogInformation(
                            "Activated subscription {SubscriptionId} after invoice {InvoiceCode} payment. {PreviousStatus} -> Active",
                            subscription.SubscriptionId,
                            invoice.InvoiceCode,
                            previousStatus ?? "(null)");
                    }

                    await CustomerSpendHelper.TryIncrementTotalSpentAsync(
                        _context,
                        _logger,
                        invoice.CustomerId,
                        payment.Amount,
                        $"Subscription#{subscription.SubscriptionId}",
                        cancellationToken);
                }
                else if (invoice.WorkOrderId.HasValue)
                {
                    _logger.LogDebug(
                        "Invoice {InvoiceId} links to WorkOrder {WorkOrderId}. Spend recognition will happen when appointment {AppointmentId} completes.",
                        invoice.InvoiceId,
                        invoice.WorkOrderId,
                        invoice.WorkOrder?.Appointment?.AppointmentId);
                }
                else
                {
                    await CustomerSpendHelper.TryIncrementTotalSpentAsync(
                        _context,
                        _logger,
                        invoice.CustomerId,
                        payment.Amount,
                        $"Invoice#{invoice.InvoiceCode}",
                        cancellationToken);
                }
            }
        }
        catch (Exception ex)
        {
            // Log error but don't fail the payment completion
            _logger.LogError(ex,
                "Failed to synchronize payment status to Appointment for Invoice {InvoiceId}. Payment still completed successfully.",
                payment.InvoiceId);
        }
    }

    #endregion

    private async Task UpdatePaymentIntentAfterGatewayAsync(
        Payment payment,
        decimal amount,
        string newStatus,
        string? gatewayTransactionId,
        CancellationToken cancellationToken)
    {
        // Try to find PaymentIntent by ProviderIntentId first
        var paymentIntent = await _context.PaymentIntents
            .Include(pi => pi.Appointment)
            .FirstOrDefaultAsync(pi => pi.ProviderIntentId == payment.PaymentCode, cancellationToken);

        Invoice? invoice = null;

        // If not found by ProviderIntentId, try to find by Invoice -> Appointment
        if (paymentIntent == null)
        {
            invoice = await _context.Set<Invoice>()
                .Include(i => i.WorkOrder)
                    .ThenInclude(w => w!.Appointment)
                        .ThenInclude(a => a.PaymentIntents)
                .FirstOrDefaultAsync(i => i.InvoiceId == payment.InvoiceId, cancellationToken);

            if (invoice?.WorkOrder?.Appointment != null)
            {
                // Find the most recent pending PaymentIntent for this appointment
                paymentIntent = invoice.WorkOrder.Appointment.PaymentIntents
                    .Where(pi => pi.Status == PaymentIntentStatusEnum.Pending.ToString())
                    .OrderByDescending(pi => pi.CreatedDate)
                    .FirstOrDefault();
            }
        }

        if (paymentIntent == null && invoice != null &&
            TryExtractAppointmentIdFromInvoiceNotes(invoice.Notes, out var fallbackAppointmentId))
        {
            paymentIntent = await _context.PaymentIntents
                .Include(pi => pi.Appointment)
                .Where(pi => pi.AppointmentId == fallbackAppointmentId &&
                             pi.Status == PaymentIntentStatusEnum.Pending.ToString())
                .OrderByDescending(pi => pi.CreatedDate)
                .FirstOrDefaultAsync(cancellationToken);

            if (paymentIntent != null)
            {
                _logger.LogInformation(
                    "Linked payment intent {IntentCode} for Appointment {AppointmentId} via invoice note fallback",
                    paymentIntent.IntentCode,
                    paymentIntent.AppointmentId);
            }
        }

        if (paymentIntent == null)
        {
            _logger.LogDebug("No PaymentIntent linked to payment {PaymentCode}", payment.PaymentCode);
            return;
        }

        paymentIntent.Status = newStatus;
        paymentIntent.UpdatedDate = DateTime.UtcNow;
        paymentIntent.PaymentMethod ??= payment.Method?.MethodName;
        paymentIntent.ProviderIntentId = payment.PaymentCode;

        if (!string.IsNullOrEmpty(gatewayTransactionId))
        {
            paymentIntent.IdempotencyKey ??= gatewayTransactionId;
        }

        if (newStatus == PaymentIntentStatusEnum.Completed.ToString())
        {
            paymentIntent.CapturedAmount = amount;
            paymentIntent.ConfirmedDate = DateTime.UtcNow;

            if (paymentIntent.Appointment != null)
            {
                // When the invoice is not linked back to the appointment (e.g. pre-payment invoice before work order),
                // ensure the appointment reflects the latest payment status and totals.
                paymentIntent.Appointment.PaymentStatus = PaymentStatusEnum.Completed.ToString();
                var existingPaid = paymentIntent.Appointment.PaidAmount ?? 0m;
                paymentIntent.Appointment.PaidAmount = Math.Max(existingPaid, amount);
                paymentIntent.Appointment.UpdatedDate = DateTime.UtcNow;
            }
        }
        else if (newStatus == PaymentIntentStatusEnum.Failed.ToString())
        {
            paymentIntent.FailedDate = DateTime.UtcNow;

            if (paymentIntent.Appointment != null &&
                paymentIntent.Appointment.PaymentStatus != PaymentStatusEnum.Completed.ToString())
            {
                paymentIntent.Appointment.PaymentStatus = PaymentStatusEnum.Failed.ToString();
                paymentIntent.Appointment.UpdatedDate = DateTime.UtcNow;
            }
        }
    }

    private static bool TryExtractAppointmentIdFromInvoiceNotes(string? notes, out int appointmentId)
    {
        appointmentId = default;
        if (string.IsNullOrWhiteSpace(notes))
        {
            return false;
        }

        var match = Regex.Match(notes, @"Appointment[^()]*\(ID:\s*(\d+)\)", RegexOptions.IgnoreCase);
        return match.Success && int.TryParse(match.Groups[1].Value, out appointmentId);
    }

    #region Private Helper Methods - Mapping

    /// <summary>
    /// Map Payment entity to response DTO
    /// </summary>
    private static PaymentResponseDto MapToResponseDto(Payment payment)
    {
        // Get first OnlinePayment record if exists (for gateway details)
        var onlinePayment = payment.OnlinePayments?.FirstOrDefault();

        return new PaymentResponseDto
        {
            PaymentId = payment.PaymentId,
            PaymentCode = payment.PaymentCode,
            InvoiceId = payment.InvoiceId,
            InvoiceCode = payment.Invoice!.InvoiceCode,
            InvoicePaidAmount = payment.Invoice?.PaidAmount,
            InvoiceOutstandingAmount = payment.Invoice?.OutstandingAmount,
            PaymentMethodId = payment.MethodId,
            PaymentMethodName = payment.Method?.MethodName ?? "Unknown",
            Amount = payment.Amount,
            NetAmount = payment.NetAmount,
            Fee = payment.ProcessingFee,
            PaymentDate = payment.PaymentDate,
            CompletedDate = payment.Status == PaymentStatus.Completed ? payment.PaymentDate : null,
            Status = payment.Status ?? PaymentStatus.Pending,
            TransactionRef = payment.TransactionRef,
            GatewayTransactionId = onlinePayment?.GatewayTransactionId,
            ResponseCode = onlinePayment?.ResponseCode,
            ResponseMessage = onlinePayment?.ResponseMessage,
            Notes = payment.Notes,
            RefundAmount = payment.RefundAmount,
            RefundDate = payment.RefundDate,
            RefundReason = payment.RefundReason,
            CreatedBy = payment.ProcessedBy,
            CreatedDate = payment.CreatedDate ?? DateTime.UtcNow
        };
    }

    #endregion
}







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































